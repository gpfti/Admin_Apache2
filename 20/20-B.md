# Archivos de configuración de Apache.

El servidor Apache se configura mediante archivos. Estos archivos se ubican y cambian de nombre en función de la distribución de Linux utilizada, aunque su finalidad y cometido es la misma.

Por lo tanto, en primer lugar debemos tener en cuenta lo siguiente. 

* Para las distribuciones basadas en ***Debian/Ubuntu***, el directorio principal donde se encuentran estos archivos es `/etc/apache2`.

* Para las basadas en ***Red Hat/CentOS***, el directorio es `/etc/httpd/conf`.


## El archivo de configuración principal de Apache.

 - Para ***Debian/Ubuntu***, el archivo es `/etc/apache2/apache2.conf`.  
 - Para ***Red Hat/CentOS*** es `/etc/httpd/conf/httpd.conf`.  
 
En ambos casos contiene las configuraciones generales de Apache. Incluye configuraciones como los puertos en los que Apache escucha, los usuarios y grupos con los que se ejecuta Apache, directivas globales de servidor y más. Es el punto de entrada para la configuración de Apache.

---

## Otros archivos de configuración (y carpetas que los contienen según el tipo):

Como iremos aprendiendo, existen otros archivos donde podemos establecer configuraciones en Apache. A diferencia del archivo de configuración principal, estos son archivos que mantienen configuraciones concretas, muy especializadas. Estos son:

### Otros archivos de configuración:

- ***ports.conf***: Este archivo define los puertos en los que Apache escucha las solicitudes entrantes. Por defecto, escucha en el puerto `80` para HTTP y en el puerto `443` para HTTPS (si está habilitado). Aquí se pueden cambiar los puertos si es necesario.

### Carpetas especializadas de configuración 

#### Sitios web:  

- ***sites-available/***: En este directorio se encuentran los archivos de configuración de los distintos sitios web disponibles en el servidor. Cada archivo dentro de este directorio, se corresponde con un sitio web y define la configuración específica para ese sitio, como el directorio raíz del sitio, la configuración de host virtual (VirtualHost), opciones de seguridad y más.

- ***sites-enabled/***: Este directorio contiene enlaces simbólicos a los archivos de configuración de los sitios disponibles que están activos. Cuando se habilita un sitio web, se crea un enlace simbólico desde ***sites-enabled/*** al archivo de configuración correspondiente en ***sites-available/***.

  
#### Configuraciones adicionales para Apache:  

- ***conf-available/***: Contiene archivos de configuración adicionales que pueden ser incluidos en la configuración principal de Apache.

- ***conf-enabled/***: Similar a ***mods-enabled/*** y ***sites-enabled/***, este directorio contiene enlaces simbólicos a los archivos de configuración que están activos.


#### Módulos Apache:  

- ***mods-available/***: Aquí se encuentran los archivos de configuración de los módulos disponibles para Apache. Cada archivo corresponde a un módulo específico, como ***rewrite***, ***ssl***, ***php***, etc. que serán explicados más adelante.

- ***mods-enabled/***: Al igual que con los sitios web, este directorio contiene enlaces simbólicos a los archivos de configuración de los módulos que están activos.

Para habilitar o deshabilitar módulos, sitios o configuraciones, se utilizan los comandos a2enmod, a2ensite, a2enconf y sus contrapartes a2dismod, a2dissite, a2disconf.

Patrón para entender estos comandos:
 - "a2en" (Apache2 ENable) Habilita + "lo que sea":  
 - "a2dis" (Apache2 DISable) Deshabilita + "lo que sea":  
 
| Comando     | ¿Qué hace?                                                                  |
| ----------- | --------------------------------------------------------------------------- |
| `a2enmod`   | Habilita un **módulo** de Apache (crea enlace simbólico en `mods-enabled`). |
| `a2dismod`  | Deshabilita un módulo (elimina el enlace simbólico de `mods-enabled`).      |
| `a2ensite`  | Activa un **sitio virtual** (`.conf`) desde `sites-available`.              |
| `a2dissite` | Desactiva un sitio virtual.                                                 |
| `a2enconf`  | Activa un archivo de **configuración adicional** desde `conf-available`.    |
| `a2disconf` | Desactiva un archivo de configuración adicional.                            |
  
**¡Apache no aplica automáticamente los cambios!**

Después de ejecutar cualquiera de esos comandos, debes hacer uno de estos para que Apache recargue la nueva configuración:

Recargar sin reiniciar (recomendado):
```
sudo systemctl reload apache2
```

O reiniciar completamente (menos recomendable):
```
sudo systemctl restart apache2
```

También puedes verificar que la configuración es válida antes de recargar:
```
sudo apache2ctl configtest
```
Si todo está bien, verás algo como:
```
Syntax OK
```

**EJEMPLOS**  

**Habilitar módulos**

1. **Habilitar `mod_rewrite` (para URLs amigables):**

```bash
sudo a2enmod rewrite
sudo systemctl reload apache2
```

---

2. **Habilitar `mod_ssl` (para HTTPS):**

```bash
sudo a2enmod ssl
sudo systemctl reload apache2
```

---

3. **Habilitar `mod_headers` (para manipular encabezados HTTP):**

```bash
sudo a2enmod headers
sudo systemctl reload apache2
```

---

**Deshabilitar módulos**

1. **Deshabilitar `mod_rewrite`:**

```bash
sudo a2dismod rewrite
sudo systemctl reload apache2
```

---

2. **Deshabilitar `mod_ssl`:**

```bash
sudo a2dismod ssl
sudo systemctl reload apache2
```

---

**Verificar módulos habilitados**

```bash
apache2ctl -M
```

Esto lista todos los **módulos cargados actualmente**.  

---

## ACTIVIDAD PRÁCTICA.

Localiza y edita el archivo de configuración principal de Apache. Estudia la configuración que ofrece una instalación por defecto de Apache. A continuación, localiza y si existe, estudia el contenido de los archivos y directorios de configuración `ports.conf`, `sites-available/`, `sites-enabled/`, `mods-available/`, `mods-enabled/`, `conf-available/` y `conf-enabled/`

Responde las siguientes preguntas:

1. Puertos e IPs a las que responde el servidor Apache.
2. ¿Cuántos sitios web tiene definido el servidor?
3. Localiza los enlaces simbólicos a los archivos de configuración de los sitios disponibles que están activos.
4. Enumera los módulos que tiene cargado el servidor Apache.

---  
---  

## Sintaxis de los archivos de configuración.

Toda la información que vas a aprender aquí se aplican a los archivos de configuración. A modo de resumen, debemos tener en cuenta que:

* Los archivos de configuración de Apache contienen una directiva por línea. El backslash `\` se puede utilizar como el último carácter en una línea para indicar que la directiva continúa en la siguiente línea. No debe haber otros caracteres o espacios en blanco entre el backslash y el final de la línea.

* Los argumentos de las directivas están separados por `espacios en blanco`. Si un argumento contiene espacios, debemos encerrar ese argumento entre comillas. 

* Las directivas en los archivos de configuración no distinguen entre mayúsculas y minúsculas, pero los argumentos de las directivas a menudo sí son sensibles a las mayúsculas y minúsculas.

* Las líneas que comienzan con el carácter de almohadilla `#` se consideran comentarios y se ignoran. Los comentarios no pueden incluirse en una línea después de una directiva de configuración.

* Las líneas en blanco y el espacio en blanco que ocurre antes de una directiva se ignoran, por lo que podemos indentar las directivas para mayor claridad.

* Los valores de las variables definidas con `DEFINE` o `variables de entorno de la shell` pueden ser utilizados en los archivos de configuración usando la sintaxis `${VAR}`, donde ***VAR*** es el nombre de una variable válida. El valor de esa variable se sustituye en ese lugar en la línea del archivo de configuración, y el procesamiento continúa como si ese texto se encontrara directamente en el archivo de configuración. 

* Las variables definidas con `DEFINE` tienen prioridad sobre las variables de entorno de la shell. Si no se encuentra la variable ***VAR***, los caracteres `${VAR}` se dejan sin cambios y se registra una advertencia. 

* Los nombres de las variables no pueden contener dos puntos `:`.

* Solo las variables de entorno de la shell definidas antes de que se inicie el servidor pueden ser utilizadas en expansiones. 

* Se pueden verificar los archivos de configuración en busca de errores de sintaxis sin iniciar el servidor utilizando `apachectl configtest` o la opción de línea de comandos `-t`.


---

## ¿Qué compone un archivo de configuración de Apache? - Introducción a las directivas y los containers

Un archivo de configuración de Apache (como `apache2.conf`, `000-default.conf`, o cualquier archivo en `sites-available`) está compuesto principalmente por:

### **Directivas**

**Las directivas son órdenes o instrucciones que Apache entiende y ejecuta.** Se escriben en los archivos de configuración y definen cómo debe comportarse el servidor.

**Ejemplo simple de directiva:**

```apache
ServerName www.ejemplo.com
```

Esta directiva le dice a Apache cómo se llama el sitio que va a servir.

---

### **Contenedores (Containers)**

**Son bloques que agrupan directivas para aplicarlas solo a un contexto específico.**

Son como “**carpetas de configuración**” que definen dónde o cuándo se aplican ciertas reglas. Por ejemplo:

* A una carpeta del sitio.
* A un host virtual.
* A un tipo de archivo.

**Ejemplo de directiva:**  
`<Directory>`  
Entre `<Directory>` y `</Directory>` hay directivas aplicadas exclusivamente al ámbito definido.

Aplica reglas a un **directorio físico del sistema de archivos**.

```apache
<Directory /var/www/html>
    Options Indexes FollowSymLinks
    AllowOverride None
    Require all granted
</Directory>
```

Este contenedor con directivas indica que:  
`Options Indexes FollowSymLinks`  
para todo lo que esté en /var/www/html permite listar el contenido del directorio, seguir enlaces simbólicos, y deja acceder a todo el mundo (no es recomendable por seguridad, pero es lo que dice esa directiva).

`AllowOverride None`  
Esto desactiva completamente el uso de archivos `.htaccess` dentro de `/var/www/html` y sus subdirectorios. Todo lo que quieras configurar debe estar en los archivos principales de Apache (como `apache2.conf` o los sitios en `sites-available/`).

`Require all granted`  
Esto permite **acceso total** al contenido del directorio a cualquier cliente, sin restricciones de IP ni autenticación. Si no estuviera, Apache podría bloquear el acceso por defecto.

Los contenedores son, por tanto, **estructuras delimitadas por etiquetas** que agrupan directivas bajo un contexto específico. Aunque después profundizaremos un poco más en los contenedores, los más importantes son:

#### 1. `<VirtualHost>`

Define un sitio web o una configuración según el puerto/IP:

```apache
<VirtualHost *:80>
    ServerName ejemplo.com
    DocumentRoot /var/www/ejemplo
</VirtualHost>
```

#### 2. `<Directory>`

Aplica directivas a un **directorio físico** del sistema de archivos:

```apache
<Directory /var/www/ejemplo>
    AllowOverride All
    Require all granted
</Directory>
```

#### 3. `<Location>`

Aplica directivas a una **ruta virtual** (URL), no a carpetas del disco:

```apache
<Location /admin>
    Require ip 192.168.1.0/24
</Location>
```

#### 4. `<Files>` y `<FilesMatch>`

Aplican directivas a **archivos concretos** o que cumplen con un patrón:

```apache
<Files ".htaccess">
    Require all denied
</Files>
```

#### 5. `<IfModule>` y `<If>`

Permiten condicionales:

```apache
<IfModule mod_rewrite.c>
    RewriteEngine On
</IfModule>
```

---

### C. **Comentarios**

Todo lo que empieza por `#` es ignorado por Apachen (ya lo habiamos introducido, pero lo ponemos aquí otra vez):

```apache
# Este es un comentario
```

---

## 2. ¿Cómo conviven estos elementos?

Apache evalúa los archivos de configuración en capas o niveles jerárquicos. La **misma directiva puede aparecer varias veces**, pero su efecto dependerá del contexto en el que esté definida.

---

## 3. Orden de prioridad de las directivas y bloques

Del más general al más específico, el orden de aplicación de las configuraciones es:

| Nivel             | Contexto                                                    | Ubicación típica                 |
| ----------------- | ----------------------------------------------------------- | -------------------------------- |
| 1. Global         | Fuera de cualquier bloque                                   | `apache2.conf`, `ports.conf`     |
| 2. VirtualHost    | Dentro de `<VirtualHost>`                                   | Archivos en `sites-available/`   |
| 3. Directory      | Dentro de `<Directory>`                                     | Anidado en VirtualHost o global  |
| 4. Location/Files | Dentro de `<Location>` o `<Files>`                          | Afecta URLs o archivos concretos |
| 5. .htaccess      | Archivos por carpeta, si está permitido con `AllowOverride` | En carpetas del sitio web        |

**Nota importante:** `.htaccess` **solo funciona si en el `<Directory>` correspondiente se ha permitido `AllowOverride`**. Si no, Apache lo ignora.

---

## 4. Ejemplo ilustrativo de convivencia

```apache
# Configuración global
ServerTokens Prod
Timeout 60

<VirtualHost *:80>
    ServerName ejemplo.com
    DocumentRoot /var/www/ejemplo

    <Directory /var/www/ejemplo>
        AllowOverride All
        Options Indexes FollowSymLinks
        Require all granted
    </Directory>

    <Location /admin>
        Require ip 192.168.1.0/24
    </Location>

    <Files ".htaccess">
        Require all denied
    </Files>
</VirtualHost>
```

En este ejemplo:

* Las directivas globales afectan a todo el servidor.
* Dentro del bloque `<VirtualHost>` se definen reglas solo para ese dominio.
* El bloque `<Directory>` controla permisos para una ruta física.
* `<Location>` restringe el acceso a una ruta URL.
* `<Files>` protege un archivo específico.


  
## Módulos en el archivo de configuración.

Apache es un servidor modular. El servidor Apache incluye una funcionalidad básica determinada de entrada, al que se le pueden añadir, a posteriori, funcionalidades adicionales.  

Estas funcionalidades adicionales o características extendidas están disponibles a través de módulos que pueden ser cargados a eleccion en Apache. Es decir, que muchas de las funcionalidades disponibles no vienen activadas por defecto, sino que se añaden en forma de módulos. 

### ¿Dónde están esos módulos?
Los hemos introducido anteriormente su ubicación es: 

- Archivos de definición en: /etc/apache2/mods-available/
- Archivos activación en: /etc/apache2/mods-enabled/

Cada módulo tiene 2 archivos (normalmente un administrador de sistemas no muy avanzado no se mete mucho con esto):  
nombre.load: indica qué archivo .so (la librería del módulo) cargar.  
nombre.conf: (opcional) contiene configuración asociada al módulo.  

Cuando activas un módulo con a2enmod, simplemente se crea un enlace simbólico desde mods-available hacia mods-enabled.

### ¿Cómo se utilizan?  
Lo primero, si quieres usar las funcionalidades del módulo, es activarlos. Puedes hacerlo desde linea de comandos del sistema (así se suele hacer normalmente). Se activan con 'a2enmod':
```bash
sudo a2enmod rewrite
```

Se pueden usar en la configuración si están activados. Por ejemplo, el módulo mod_rewrite permite directivas como:
```apache
RewriteEngine On
RewriteRule ^pagina$ pagina.html
```

Si el módulo no está activado, esa directiva generará un error.

Por defecto, una serie de módulos se incluyen en el servidor, aunque para ser precisos, depende de la distribución de Linux que se esté usando. Estos son:

- ***mod_ssl***: Este módulo proporciona soporte para HTTPS (HTTP sobre SSL/TLS), permitiendo la encriptación de las comunicaciones entre el cliente y el servidor.

- ***mod_rewrite***: Se utiliza para manipular (rewrite) URLs en el servidor. Es muy útil para redireccionamientos, reescrituras de URL y otras tareas relacionadas con la gestión de la URL.

- ***mod_alias***: Proporciona funciones para gestionar alias y redirecciones dentro del servidor. Por ejemplo, se utiliza para crear alias de directorios o redireccionar URL.

- ***mod_auth_basic***: Permite la autenticación básica HTTP, que es un método simple de autenticación donde el servidor solicita un nombre de usuario y una contraseña al cliente.

- ***mod_auth_digest***: Proporciona autenticación digest HTTP, una forma más segura de autenticación que la autenticación básica, ya que las credenciales se envían en forma de hash.

- ***mod_deflate/mod_gzip***: Estos módulos proporcionan compresión de contenido para reducir el tamaño de los archivos que se envían desde el servidor al cliente, lo que puede mejorar significativamente el rendimiento de la carga de la página.

- ***mod_headers***: Permite la manipulación de encabezados HTTP tanto en las solicitudes como en las respuestas. Esto puede ser útil para añadir, modificar o eliminar encabezados según sea necesario.

- ***mod_expires***: Se utiliza para controlar la caché del navegador mediante la configuración de tiempos de expiración para diferentes tipos de archivos.

---

### Los módulos en Apache se pueden habilitar y activar desde los archivos de configuración

#### **Carga y uso condicional de módulos en Apache**

##### 1. Cargar módulos manualmente con `LoadModule`

Aunque en Debian/Ubuntu se suele usar `a2enmod`, también puedes **cargar un módulo directamente** en cualquier archivo de configuración con:

```apache
LoadModule rewrite_module /usr/lib/apache2/modules/mod_rewrite.so
```

Esto indica a Apache que cargue ese módulo y lo active.
**Normalmente no necesitas escribirlo manualmente**, porque `a2enmod` ya lo añade automáticamente en `mods-enabled/*.load`.

---

##### 2. Usar directivas solo si un módulo está disponible (activo): `<IfModule>`

A veces quieres escribir reglas que **solo funcionen si el módulo necesario está activo**. Para eso usamos `<IfModule>`:

```apache
<IfModule mod_rewrite.c>
    RewriteEngine On
    RewriteRule ^oferta$ ofertas.html
</IfModule>
```
Esto lo que hace es: 
 - Si `mod_rewrite` está habilitado, Apache ejecuta las directivas dentro.
 - Si no está habilitado, Apache **las ignora** silenciosamente.

Esto es útil para que tu configuración sea más **portátil y tolerante a fallos**.

---

Si quieres que Apache **no arranque** si el módulo no está, entonces **NO uses `<IfModule>`**. Simplemente escribe las directivas directamente, y Apache lanzará un error si no reconoce la directiva (porque el módulo no está cargado).

Para ver los módulos cargados en Apache en Ubuntu, puedes utilizar el comando `apachectl` con la opción `-M`.

```bash
sudo apachectl -M
```

En la siguiente imagen puedes ver una captura parcial de los módulos disponibles en el servidor Apache.

![Módulos cargados](../img/20/202403220947.png)
 
Para la implementación del servidor Apache en Red Hat/CentOS, usamos el comando `httpd` en lugar de `apachectl`.

```bash
sudo httpd -M
```

![Módulos cargados 2](../img/20/202403221007.png)

## Ámbito de las directivas.

Las directivas colocadas en los archivos de configuración principales `/etc/apache2/apache2.conf` o `/etc/httpd/conf/httpd.conf` se aplican a todo el servidor. Si deseamos cambiar la configuración solo para una parte del servidor, podemos limitar el alcance de esas directivas colocándolas dentro de secciones `<DIRECTORY>`, `<DIRECTORYMATCH>`, `<FILES>`, `<FILESMATCH>`, `<LOCATION>` y `<LOCATIONMATCH>`. Estas secciones limitan la aplicación de las directivas que encierran a ubicaciones específicas del sistema de archivos o URLs particulares. 

Apache tiene la capacidad de servir muchos sitios web diferentes simultáneamente. Esto se llama ***Alojamiento Virtual*** o `Virtual Host`. Las directivas también pueden estar limitadas al colocarlas dentro de secciones `<VIRTUALHOST>`, de modo que solo se apliquen a solicitudes para un sitio web en particular. Esta es la configuración preferida.

Aunque la mayoría de las directivas pueden colocarse en cualquiera de estas secciones, algunas directivas no tienen sentido en ciertos contextos. Por ejemplo, las directivas que controlan la creación de procesos solo pueden colocarse en el contexto del servidor principal. 

## Los archivos .htaccess

Apache permite la gestión descentralizada de la configuración a través de archivos especiales colocados dentro de los directorios de los Virtual Hosts. Estos archivos especiales suelen llamarse `.htaccess`, pero se puede especificar cualquier nombre en la directiva `ACCESSFILENAME` (No suele ser común renombrarlos). 

Las directivas colocadas en archivos `.htaccess` se aplican al directorio donde se coloca el archivo, así como a todos sus subdirectorios. Los archivos `.htaccess` siguen la misma sintaxis que los archivos de configuración principales. Dado que los archivos `.htaccess` se leen en cada solicitud (request http), los cambios realizados en estos archivos tienen efecto inmediato.

Más adelante, en el curso, veremos a fondo el uso de los archivos `.htaccess`. Por ahora es suficiente que conozcas para qué sirven.

## Secciones de configuración (contenedores/containers)

Las directivas en los archivos de configuración pueden aplicarse al servidor completo, o pueden estar restringidas para aplicarse solo a directorios (virtual hosts) o URLs concretas. 

Estas secciones en los archivos de configuración se definen por medio de los `containers` o contenedores. La mayoría de ellos se ejecutan por cada request de http, excepto para los contenedores `IfDefine`, `IfModule` e `IfVersion`, que solo se evalúan en el momento de iniciar el servidor.

El siguiente fragmento, que podríamos encontrar en el archivo de configuración, evalúa si se ha definido ***ClosedForNow*** y, si es el caso, redirecciona todas las request hacia otra URL.
```apache
<IfDefine ClosedForNow>
    Redirect / http://otherserver.example.com/
</IfDefine>
```
NOTA: 
ClosedForNow se define cuando se arranca el servicio con ese parametro:
```apache
sudo apachectl -D ClosedForNow
```

(o tambien redefiniendo el parametro de arranque del mismo con): 
```apache
sudo systemctl edit apache2
```

NOTA: Otros administradores avanzados lo usarán, pero se suele usar en contadísimas ocasiones.

La directiva `<IfModule>` encierra directivas que solo se aplicarán si un módulo particular está disponible en el servidor. Esta directiva solo debe usarse si necesitamos que el archivo de configuración funcione independientemente de si están disponibles o no ciertos módulos. En el siguiente ejemplo, la directiva `MIMEMAGICFILE` se aplicará solo si el módulo `MOD_MIME_MAGIC` está disponible en el servidor.

```apache
<IfModule mod_mime_magic.c>
    MimeMagicFile conf/magic
</IfModule>
```

La directiva `<IfVersion>` es muy similar a las dos anteriores, excepto que encierra directivas que solo se aplicarán si una versión particular del servidor está ejecutándose. Esta directiva es útil cuando tenemos servidores Apache con diferentes versiones y, deseamos comportamientos específicos del servidor para cada versión. Aquí tenemos un ejemplo de uso en el archivo de configuración.

```apache
<IfVersion >= 2.4.50>
    # esto sucede solo en versiones mayores o iguales a 2.4.50.
</IfVersion>
```

También debemos saber que `<IfDefine>`, `<IfModule>`, e `<IfVersion>` pueden ser utilizadas con lógica negada precediendolas del signo de admiración `!`.

## Contenedor FileSystem.

En Apache debemos conocer ciertos términos que van a ser empleados frecuentemente cuando hablamos de su configuración. Estos son:

Apache puede servir contenido estático, como archivos HTML, imágenes, CSS y JavaScript, desde el sistema de archivos del servidor. La configuración de Apache permite especificar la ubicación de los archivos y directorios en el sistema de archivos que deben ser accesibles a través del servidor web.

El contenedor `FileSystem` permite establecer directivas que se aplican al sistema de archivos. Las directivas disponibles son `Directory`, que aplican la configuración a todos los archivos del directorio,  y `Files` que aplica la configuración a los archivos que verifiquen un nombre o expresión regular.

En Apache, la directiva `<Directory>` se utiliza dentro del contenedor `<FileSystem>` para aplicar configuraciones específicas a un directorio o conjunto de directorios en el sistema de archivos del servidor. Esto permite personalizar la forma en que Apache maneja el acceso y el comportamiento dentro de esos directorios.

Se utiliza el contenedor `<Directory>` para especificar el directorio al que se aplicarán las configuraciones. Por ejemplo:

```apache
<FileSystem /var/www/html>
    <Directory /var/www/html/directorio-especifico>
        # Configuraciones específicas para el directorio
    </Directory>
</FileSystem>
```

En este ejemplo, la directiva `<Directory>` se utiliza para definir el directorio `/var/www/html/directorio-especifico` dentro del contenedor `<FileSystem>`.

Dentro del bloque de la directiva `<Directory>`, se pueden agregar varias directivas de configuración para personalizar el comportamiento de Apache dentro de ese directorio en particular. Algunas de las configuraciones comunes que se pueden aplicar incluyen:

   - `AllowOverride`: Permite que se anulen las configuraciones del archivo `.htaccess` en el directorio.
   - `Options`: Especifica las opciones de configuración disponibles para el directorio, como permitir o denegar la ejecución de scripts CGI o el seguimiento de enlaces simbólicos.
   - `Order`, `Deny`, `Allow`: Controla el acceso al directorio basado en direcciones IP, nombres de host o usuarios.
   - `Require`: Especifica los requisitos de autenticación para acceder al directorio.

Por ejemplo:

```apache
<Directory /var/www/html/directorio-especifico>
    AllowOverride All
    Options Indexes FollowSymLinks
    Order allow,deny
    Allow from all
    Require valid-user
</Directory>
```

Esto permite que se anulen las configuraciones del archivo `.htaccess`, permite el seguimiento de enlaces simbólicos, permite el acceso desde cualquier dirección IP y requiere que los usuarios se autentiquen para acceder al directorio especificado.

En resumen, la directiva `<Directory>` dentro del contenedor `<FileSystem>` en Apache es una poderosa herramienta para aplicar configuraciones específicas a directorios individuales en el sistema de archivos del servidor, lo que nos permite un control granular sobre el comportamiento y el acceso dentro de esos directorios.

La directiva `Files` en el contenedor `FileSystem` de Apache se utiliza para aplicar configuraciones específicas a archivos individuales o a conjuntos de archivos que cumplan con ciertos criterios de coincidencia. Esta directiva es parte de la configuración avanzada que permite a los administradores de Apache personalizar el comportamiento del servidor web en función de diferentes características de los archivos.

Un ejemplo sería:

```apache
<Files filename>
    Configuración específica para el archivo filename
</Files>
```

La directiva `<Files>` permite especificar un nombre de archivo o un patrón de coincidencia utilizando expresiones regulares para aplicar la configuración a múltiples archivos.

Dentro del bloque `<Files>`, se puede incluir cualquier configuración válida de Apache, como directivas de acceso, opciones, encabezados, etc. Esta configuración se aplicará solo a los archivos que coincidan con los criterios especificados. Por ejemplo:

```apache
<Files "config.php">
    Require all denied
</Files>
```

En este caso, la configuración dentro del contenedor `<Files>` niega el acceso a cualquier solicitud de archivo llamado `config.php`. Esto proporciona una capa adicional de seguridad al restringir el acceso a archivos sensibles como archivos de configuración.


## Directiva Location.

La directiva `Location` en Apache se utiliza para definir cómo se debe procesar una solicitud HTTP para un recurso específico o conjunto de recursos en función de la URL solicitada. Permite configurar acciones y restricciones específicas para una ubicación determinada dentro del espacio web servido por Apache. Esto es útil para aplicar configuraciones específicas a ciertos directorios, archivos o URL dentro de un sitio web.

Podemos utilizar la directiva `Location` para especificar una URL relativa o absoluta que represente una ubicación específica dentro del espacio web del servidor. Por ejemplo:
```apache
<Location /images>
    # Configuración específica para la ubicación /images
</Location>
```

Dentro de la directiva `Location`, se pueden incluir otras directivas de configuración de Apache para aplicar configuraciones específicas a la ubicación definida. Como `Allow`, `Deny`, `Require`, `Options`, `RewriteRule`, entre otras, según las necesidades del sitio web. Por ejemplo:

```apache
<Location /private>
    Require ip 192.168.1.0/24
    # Restringe el acceso a la ubicación /private a una dirección IP específica
</Location>
```

La directiva `Location` realiza una coincidencia de prefijo, lo que significa que coincidirá con cualquier URL que comience con la ubicación especificada. Por ejemplo, la ubicación `/images` coincidirá con `/images/photo.jpg`, `/images/gallery.html`, etc. Sin embargo, la coincidencia es sensible a mayúsculas y minúsculas, a menos que se especifique lo contrario.

La directiva `Location` se puede anidar dentro de otras directivas de configuración de Apache, como `<VirtualHost>`, `<Directory>`, `<Files>`, entre otras. Esto permite una gran flexibilidad para definir configuraciones específicas en diferentes contextos dentro de la configuración del servidor.


## Expresiones booleanas.

Las expresiones booleanas en Apache se utilizan principalmente para condicionar el comportamiento del servidor web (como redirecciones, restricciones de acceso, o reescrituras de URL), combinando condiciones con operadores lógicos. 

Condicionan la ejecución de ciertas directivas de configuración en función de condiciones específicas. Esto proporciona una forma flexible y dinámica de ajustar el comportamiento del servidor web Apache según diferentes situaciones. 

Las expresiones booleanas se pueden utilizar en varias partes de la configuración de Apache, como en bloques condicionales `<If>`, `<IfDefine>`, `<IfModule>`, `<IfVersion>`, entre otros.

Podemos configurar Apache para realizar ciertas acciones basadas en variables de entorno del sistema. Por ejemplo, puese pueden establecer reglas que se apliquen solo si una variable de entorno específica está definida o tiene cierto valor.

```apache
<If "-n %{ENV:USERNAME}">
    # Esta directiva se aplicará solo si la variable de entorno USERNAME está definida.
</If>
```

**¿Qué es %{ENV:USERNAME} o %{...lo que sea..}?**
- Es una expresión de servidor que representa el valor de la cabecera HTTP User-Agent enviada por el cliente (navegador, bot, etc.).
- Se accede mediante %{...} en contextos como mod_rewrite, mod_setenvif, o mod_authz_core.  
Se la suele llamar variable de entorno, pero no lo es exactamente, es una variable especial del entorno de ejecución, aunque se accede a la información de una forma similar. 

También es posible establecer reglas que se apliquen solo a ciertas direcciones IP o rangos de direcciones IP.

```apache
<If "%{REMOTE_ADDR} == '192.168.1.1'">
    # Esta directiva se aplicará solo si la dirección IP del cliente es 192.168.1.1.
</If>
```

Podemos configurar Apache para aplicar ciertas reglas solo a solicitudes que coincidan con un nombre de host específico.

```apache
<If "%{HTTP_HOST} == 'example.com'">
    # Esta directiva se aplicará solo si el nombre de host de la solicitud es example.com.
</If>
```

Como ya hemos visto, podemos activar o desactivar ciertas configuraciones basadas en si un módulo específico está cargado en Apache.

```apache
<IfModule mod_ssl.c>
    # Esta directiva se aplicará solo si el módulo mod_ssl está cargado en Apache.
</IfModule>
```

También se pueden combinar múltiples condiciones utilizando operadores lógicos como AND (`&&`), OR (`||`) y NOT (`!`) para crear expresiones booleanas más complejas.

```apache
<If "%{REMOTE_ADDR} == '192.168.1.1' && %{REQUEST_URI}">
    # Esta directiva se aplicará solo si la dirección IP del cliente es 192.168.1.1
</If>
```

También podemos utilizar expresiones regulares:

Por ejemplo, coincidencia de una cadena en la URI de la solicitud:

```apache
<If "%{REQUEST_URI} =~ m#/admin/#">
    # Esta directiva se aplicará si la URI de la solicitud contiene '/admin/' en cualquier parte de la cadena.
</If>
```

En Apache, el operador `=~` se utiliza para indicar que se va a realizar una coincidencia de expresiones regulares en una cadena de texto. Esto significa que la cadena de texto se comparará con una expresión regular y se evaluará si hay coincidencias.

En el ejemplo anterior, si la variable %{REQUEST_URI}, que representa la URI de la solicitud en el servidor web Apache, coincide con la expresión regular `m#/admin/#`.

La `m` es una convención que se utiliza a menudo para delimitar expresiones regulares en Apache, `#` es el delimitador en indica el inicio y el final de la expresión regular.


Aquí tenemos otro ejemplo. Lee el comentario para saber qué hace.

```apache
<If "%{REQUEST_URI} =~ m#^/images/#">
    # Esta directiva se aplicará si la URI de la solicitud comienza con '/images/'.
</If>
```

Otro ejemplo más.

```apache
<If "%{REQUEST_URI} =~ m#/downloads/$#">
    # Esta directiva se aplicará si la URI de la solicitud termina con '/downloads/'.
</If>
```

Un ejemplo más avanzado, donde se busca la coincidencia de una dirección IP específica en el encabezado X-Forwarded-For (si está habilitado el módulo mod_remoteip):

```apache
<If "%{HTTP:X-Forwarded-For} =~ m#^192\.168\.1\.#">
    # Esta directiva se aplicará si la dirección IP en el encabezado X-Forwarded-For comienza con '192.168.1.'.
</If>
```

Otro ejemplo muy típico

```apache
<If "%{HTTP_USER_AGENT} =~ m#Firefox#">
    # Esta directiva se aplicará si el User-Agent del cliente contiene la cadena 'Firefox'.
</If>
```

---
---

## El contenedor VirtualHost.

El contenedor `VirtualHost` agrupa las directivas que se aplican a hosts específicos. Tiene utilidad cuando el servidor web va a servir diferentes aplicaciones. Como los hosts virtuales son fundamentales en Apache, vamos a desarrollarlo detalladamente más adelante. Por ahora solo debes saber que se pueden establecer configuraciones específicas para cara Virtual Host en el archivo de configuración.

Un **VirtualHost** permite que un solo servidor Apache sirva **múltiples sitios web** desde la **misma máquina**. Se basa en el nombre del dominio (o en la IP/puerto) para decidir qué contenido entregar.

Ejemplo típico: tienes una máquina y quieres que responda a:

* `midominio.com`
* `otrodominio.com`
* Ojo: tambien puedes definirlo sin nombre de dominio

con sitios completamente distintos.

---

### VirtualHost básico

Supón que quieres que Apache sirva un sitio para `midominio.com`.

#### 1. Estructura mínima:

```apache
<VirtualHost *:80>
    ServerName midominio.com
    DocumentRoot /var/www/midominio
</VirtualHost>
```

* `*:80`: Escucha en todos los interfaces de red en el puerto 80 (HTTP).
* `ServerName`: El dominio que debe coincidir con la URL que pide el cliente.
* `DocumentRoot`: Carpeta donde están los archivos HTML, etc.

#### 2. Pasos básicos para usarlo:

1. Crea la carpeta:

```bash
sudo mkdir -p /var/www/midominio
```

2. Crea un archivo de configuración:

```bash
sudo nano /etc/apache2/sites-available/midominio.conf
```

3. Pega el VirtualHost de arriba.

4. Habilita el sitio:

```bash
sudo a2ensite midominio.conf
sudo systemctl reload apache2
```

5. Asegúrate de que `midominio.com` apunta a tu servidor (puede ser en `/etc/hosts` para pruebas locales):

```plaintext
127.0.0.1 midominio.com
```

#### Virtualhost sin nombre de dominio es posible. Raro, pero posible

```apache
<VirtualHost *:80>
    # ServerName midominio.com
    DocumentRoot /var/www/midominio
</VirtualHost>
```

---  

## ACTIVIDAD PRÁCTICA.

**Configuración condicional en Apache2 usando contenedores**

### **Objetivo**

Aprender a utilizar los contenedores `<IfDefine>`, `<IfModule>`, `<IfVersion>`, `<Directory>`, `<Files>` y `<Location>`, así como expresiones booleanas para modificar el comportamiento de Apache según condiciones específicas.

### **Enunciado**

Vas a crear una configuración personalizada de Apache que cumpla con los siguientes objetivos:

1. **Bloqueo de archivo sensible**

   * En el mismo archivo de configuración, usa `<Files>` para denegar el acceso al archivo `secreto.php` en `/var/www/html`.

2. **Configuración por directorio**

   * Usa el contenedor `<Directory>` para:

     * Permitir `.htaccess`.
     * Activar índices y seguimiento de enlaces simbólicos en el directorio `/var/www/html/zona-publica`.
     * Permitir acceso a todo el mundo.
     * Requerir autenticación (puede ser simulada, no es necesario configurarla completamente).  

     Para este este apartado, crea 2 archivos dentro de `/var/www/html/zona-publica`, un index.html y un redirigida.html. Editalos y pon im ntexto dentro para identificarlos. Para comprobar que .htacess funciona, poner este código de redireccion en el .htacess: 
     	```apache
	Redirect 302 /zona-publica/index.html /zona-publica/redirigida.html
	```
     
3. **Restricción por URL**

   * Usa `<Location>` para que **solo puedan acceder a la URL `/admin` las IP del rango `192.168.56.0/24`**.

4. **Comprobación de módulo**

   * Usa `<IfModule>` para añadir una directiva que **solo se aplique si el módulo `mod_rewrite` está habilitado**. Por ejemplo, puedes añadir un `RewriteEngine On` sin definir reglas.

5. **Comprobación por versión**

   * Añade un bloque `<IfVersion>` que solo se ejecute en versiones de Apache mayores o iguales a la 2.4.50. Si cumple la condición, redirige la URL raiz a https://www.google.es 
     Prueba para una version de Apache menor de la que está instalada, de forma que si se cumple la condición, ejecute la redirección.

6. **Expresión booleana**

   * Añade un bloque `<If>` que bloquee el acceso si el User-Agent contiene la palabra `curl`.

### **Instrucciones finales**

1. Habilita el nuevo archivo de configuración con `sudo a2ensite containers.conf`.
2. Recarga Apache: `sudo systemctl reload apache2`.
3. Usa herramientas como `curl` o el navegador para probar los diferentes comportamientos.


---  

## Gestión de la caché en Apache

En Apache, el "cacheo" es un mecanismo que permite almacenar temporalmente recursos web para acelerar el tiempo de carga de las páginas y reducir la carga del servidor al servir contenido estático y dinámico. Las directivas de cacheo en Apache controlan cómo se almacenan y se sirven estos recursos en el cliente y en los servidores intermedios (como proxies).  

Las directivas `CacheEnable` y `CacheDisable` habilitan o deshabilitan el cacheo para recursos específicos en función de patrones de URL.  

La sintaxis correcta de CacheEnable y CacheDisable es:  

```apache
CacheEnable [type] [url-path]
CacheDisable [url-path]
```

Estas directivas pueden ir dentro de contenedor `<virtualhost>` como fuera. Según donde lo definamos, afecta el ambito de la definición de la caché.

Por ejemplo:

```apache
CacheEnable disk /images/ 
CacheDisable /cgi-bin/
```

En este ejemplo, el cacheo está habilitado para todos los recursos en el directorio `/images/`, pero está deshabilitado para recursos en el directorio `/cgi-bin/`.

Para estar seguros de que esta gestión de Caché funciona, es necesario estar seguros que los módulos implicados están habilitados.

```apache
sudo a2enmod cache
sudo a2enmod cache_disk
sudo systemctl reload apache2
```

**`CacheMaxExpire`** establece la cantidad máxima de tiempo (en segundos) que un recurso puede permanecer en la caché del cliente antes de que deba ser validado con el servidor de origen. Por ejemplo:

```apache
CacheMaxExpire 3600
```

Esto indica que el recurso en caché puede permanecer en la caché del cliente durante un máximo de una hora antes de que deba ser solicitado nuevamente al servidor.

**`CacheLastModifiedFactor`** controla cómo Apache calcula la fecha de expiración de un recurso basándose en su fecha de última modificación. Cuando Apache entrega un recurso y no hay cabecera Expires definida, intenta estimar una fecha de expiración usando esta fórmula:   

```apache
expires = last_modified + (now - last_modified) * CacheLastModifiedFactor
```
Donde:  
 - `now - last_modified` = cuánto tiempo hace que se modificó el recurso.  
 - Se multiplica ese tiempo por el factor (por ejemplo, 0.1).  
 - El resultado se suma a last_modified para obtener la fecha de expiración.  

Por ejemplo:

```apache
CacheLastModifiedFactor 0.1
```

Un valor de ***0.1*** significa que la fecha de expiración será el 10% del tiempo transcurrido desde la última modificación del recurso.

**Ejemplo concreto:** 
Supongamos que:  
Un recurso fue modificado por última vez hace 10 días  
No tiene cabeceras explícitas de caché  
Si se configura:
```
CacheLastModifiedFactor 0.1
```
Entonces Apache calculará:  
TTL (tiempo de expiración) = 10 días × 0.1 = 1 día  

Es decir, el recurso será considerado válido en caché durante 1 día.

---

`CacheDefaultExpire` establece la cantidad predeterminada de tiempo (en segundos) que un recurso puede permanecer en la caché del cliente antes de que deba ser solicitao de nuevo al servidor de origen.

```apache
CacheDefaultExpire 604800
```

Esto establece un tiempo de expiración predeterminado de una semana para los recursos en caché.

`CacheIgnoreCacheControl` controla si Apache debe ignorar las directivas de control de caché proporcionadas por el servidor de origen. Por ejemplo:

```apache
CacheIgnoreCacheControl on
```

Indica que Apache ignorará las directivas de control de caché proporcionadas por el servidor de origen y aplicará su propia política de caché.

## ACTIVIDAD PRÁCTICA.

Experimenta con la caché del servidor Apache. 

Crea una página web sencilla que use una CSS e incorpore una imagen jpeg y móntala en tu servidor Apache.

Dentro del archivo de configuración principal de Apache, busca las secciones relacionadas con la configuración de la caché. Pueden incluir directivas como `ExpiresByType`, `Header`, `FileETag`, entre otras, dependiendo de tu versión de Apache y módulos instalados.

Utiliza la directiva `ExpiresByType` para establecer tiempos de expiración de la siguiente forma

* ***archivos css*** caducidad a 1 mes.
* ***archivos jpeg*** caducidad 2 meses.

Para verificar que la configuración es correcta, debes inspeccionar los encabezados HTTP. Para ello Utiliza las herramientas de desarrollo de tu navegador web para inspeccionar los encabezados HTTP de la respuesta que devuelve el servidor cuando solicita la imagen JPEG. Esto te permitirá ver si hay un encabezado Cache-Control o Expires que indica la fecha de caducidad de la imagen.


## Directivas de ámbito de servidor.

Las directivas de configuración de ámbito de servidor (server-wide) en Apache son aquellas que se aplican a todo el servidor web, afectando globalmente a todas las solicitudes y todos los sitios alojados en el servidor. Estas directivas se definen en el archivo de configuración principal de Apache y pueden influir en aspectos críticos del comportamiento del servidor.

Las más habituales son las siguientes:

`ServerRoot`especifica el directorio raíz del servidor web, donde se encuentran los archivos de configuración, los archivos de registro y otros recursos importantes para el funcionamiento del servidor.

```apache
ServerRoot "/etc/apache2"
```

`Listen` indica al servidor en qué direcciones IP y puertos debe escuchar las solicitudes entrantes. Por lo general, Apache está configurado para escuchar en el puerto ***80 para HTTP*** y en el puerto ***443 para HTTPS***.

```apache
Listen 80
Listen 443
```

`User` y `Group`: Estas directivas especifican el usuario y el grupo bajo los cuales se ejecutará el servidor web. Es importante configurar estos valores correctamente para garantizar la seguridad y los permisos adecuados en el servidor.

```apache
User www-data
Group www-data
```

En el contexto de la seguridad del servidor Apache, `www-data` es un nombre de usuario comúnmente utilizado por defecto en sistemas operativos Linux para ejecutar el proceso del servidor web Apache. Aunque el nombre de usuario puede variar según la distribución y la configuración del sistema, `www-data` es el nombre predeterminado utilizado en muchas distribuciones.

El uso de un usuario dedicado como `www-data` para ejecutar el servidor web Apache tiene implicaciones importantes en cuanto a la seguridad del servidor:

- ***Principio de menor privilegio***: Al ejecutar Apache con un usuario específico como ***www-data***, el servidor web tiene acceso limitado solo a los recursos necesarios para servir páginas web. Esto es consistente con el ***principio de menor privilegio***, lo que significa que el servidor web tiene solo los privilegios mínimos necesarios para funcionar correctamente, lo que ayuda a reducir el impacto de posibles vulnerabilidades en el servidor.

- ***Aislamiento de recursos***: El uso de un usuario dedicado como ***www-data*** ayuda a aislar los recursos del servidor web de otros usuarios y procesos en el sistema. Esto significa que el servidor web no tiene acceso indiscriminado a todos los archivos del sistema, lo que puede ayudar a mitigar el riesgo de compromiso del sistema en caso de una vulnerabilidad en el servidor web.

- ***Control de acceso***: Al tener un usuario dedicado para ejecutar el servidor web, es posible aplicar controles de acceso y políticas de seguridad específicas para el usuario ***www-data***". Esto puede incluir la configuración de permisos de archivos y directorios para limitar el acceso del servidor web solo a los archivos necesarios para su funcionamiento.


La directiva `ServerAdmin` establece la dirección de correo electrónico del administrador del servidor, que se incluye en las páginas de error generadas por el servidor. Es opcional.

```apache
ServerAdmin admin@example.com
```

`ErrorLog` y `CustomLog` especifican la ubicación de los archivos de registro de errores y de acceso. Este tema, debido a su importancia, será tratado de forma detallada más adelante.

```apache
ErrorLog "/var/log/apache2/error.log"
CustomLog "/var/log/apache2/access.log" combined
```

`Timeout` define el tiempo máximo en segundos que el servidor esperará por una solicitud antes de finalizar la conexión.

```apache
Timeout 300
```

`KeepAlive` controla si el servidor permitirá conexiones persistentes (keep-alive) con los clientes para reducir la latencia en las solicitudes posteriores.

```apache
KeepAlive On
```

Una conexión `keep-alive` permite que múltiples solicitudes y respuestas HTTP se realicen a través de una única conexión TCP, en lugar de abrir y cerrar una nueva conexión TCP para cada solicitud individual. Esto mejora significativamente el rendimiento y la velocidad de carga de las páginas web al reducir la sobrecarga asociada con el establecimiento de nuevas conexiones TCP.

Cuando la directiva `KeepAlive` está configurada como `On`, el servidor Apache permitirá conexiones persistentes y mantendrá abierta la conexión TCP durante un tiempo especificado (`KeepAliveTimeout`) después de que se haya completado la primera solicitud. Durante este tiempo, el servidor puede enviar y recibir múltiples solicitudes y respuestas a través de la misma conexión TCP.

Por otro lado, cuando la directiva `KeepAlive` está configurada como `Off`, el servidor cerrará la conexión TCP después de completar cada solicitud individual, lo que significa que se abrirá una nueva conexión para cada solicitud entrante.

El uso de conexiones keep-alive puede tener varios beneficios:

- ***Reducción de la latencia***: Al evitar el proceso de establecimiento y cierre de conexiones TCP para cada solicitud, las conexiones keep-alive pueden reducir la latencia percibida por los usuarios al cargar páginas web, especialmente en conexiones de red más lentas o con un alto retardo.

- ***Mejora del rendimiento***: Al mantener abierta la conexión TCP, el servidor y el cliente pueden reutilizar los recursos existentes, lo que mejora el rendimiento general del servidor web al reducir la carga asociada con la gestión de múltiples conexiones.

- ***Reducción del consumo de recursos***: Aunque las conexiones keep-alive pueden consumir recursos adicionales al mantener abiertas las conexiones TCP, en general, pueden reducir el consumo total de recursos al evitar la sobrecarga asociada con el establecimiento de nuevas conexiones.

Es importante tener en cuenta que, si bien las conexiones keep-alive pueden mejorar el rendimiento y la velocidad de carga de las páginas web, también pueden consumir recursos adicionales en el servidor y pueden no ser adecuadas para todos los escenarios. Por lo tanto, es importante evaluar cuidadosamente el impacto de las conexiones keep-alive en el servidor y ajustar la configuración según sea necesario para optimizar el rendimiento y la estabilidad del servidor web.


La directiva `ServerTokens` controla la cantidad de información que el servidor revela en los encabezados de respuesta HTTP sobre su versión y el sistema operativo en el que se ejecuta.

La directiva `ServerTokens` en Apache controla la cantidad de información que el servidor revela en los encabezados de respuesta HTTP sobre su versión y el sistema operativo en el que se ejecuta. Esta directiva puede configurarse con diferentes valores para controlar el nivel de detalle que se muestra en los encabezados de respuesta. Aquí tienes algunos ejemplos de cómo se puede configurar la directiva `ServerTokens`:

```apache
ServerTokens Full
```

Con esta configuración, el servidor revelará información detallada en los encabezados de respuesta, incluyendo la versión exacta de Apache y el sistema operativo. No es conveniente activarla porque se le está ofreciendo demasiada información al actor de la amenaza.


```apache
ServerTokens Prod
```

Con esta configuración, el servidor solo revelará el nombre de Apache en los encabezados de respuesta, sin incluir detalles de la versión o el sistema operativo.


```apache
ServerTokens Major
```

Esta configuración mostrará solo el número principal de la versión de Apache en los encabezados de respuesta, sin revelar el número de versión completo o el sistema operativo.


```apache
ServerTokens Minor
```

Esta configuración mostrará el número principal y menor de la versión de Apache en los encabezados de respuesta, sin revelar el número de versión completo o el sistema operativo.


```apache
ServerTokens OS
```

Con esta configuración, el servidor solo revelará el nombre del sistema operativo en los encabezados de respuesta, sin incluir detalles de la versión de Apache.

Es importante tener en cuenta que, al configurar la directiva `ServerTokens`, se debe considerar cuidadosamente el equilibrio entre la privacidad y la seguridad, ya que revelar demasiada información sobre el servidor puede facilitar ataques dirigidos. Por lo tanto, en entornos de producción, es recomendable configurar `ServerTokens` con un valor que minimice la cantidad de información revelada sin comprometer la funcionalidad del servidor.

## Configuración de los archivos de log.

El servidor HTTP Apache proporciona una variedad de mecanismos diferentes para registrar todo lo que sucede en su interior, desde la solicitud inicial, pasando por el proceso de asignación de URL, hasta la resolución final de la conexión, incluidos los errores que puedan haber ocurrido en el proceso. 

Además de esto, los módulos de terceros pueden proporcionar capacidades de registro o inyectar entradas en los archivos de registro existentes, y aplicaciones como programas CGI, scripts PHP u otros controladores, pueden enviar mensajes al registro de errores del servidor. 


La directiva `ErrorLog` en Apache se utiliza para especificar la ubicación del archivo de registro de errores del servidor web. Este archivo registra todos los mensajes de error generados por el servidor durante su funcionamiento. La información registrada en el archivo de registro de errores puede incluir mensajes sobre problemas de configuración, errores del servidor, advertencias, solicitudes de clientes mal formadas, y más.

Esta directiva `ErrorLog` especifica la ruta completa del archivo de registro de errores. Esto incluye el nombre del archivo y la ruta del directorio donde se almacenará el archivo de registro.

```apache
ErrorLog "/var/log/apache2/error.log"
```
Es importante asegurarse de que el usuario bajo el cual se ejecuta el servidor web (generalmente `www-data` en sistemas basados en Linux) tenga ***permisos de escritura en el archivo de registro de error especificado. 

En entornos de producción, es común configurar la rotación de registros para evitar que los archivos de registro de errores crezcan demasiado y consuman demasiado espacio en disco. Esto puede hacerse utilizando herramientas de rotación de registros como `logrotate`.


En la mayoría de las distribuciones de Linux, Logrotate se instala por defecto. Sin embargo, si no está instalado, puedes instalarlo desde el repositorio de paquetes de tu distribución. Por ejemplo, en sistemas basados en Debian/Ubuntu, podemos instalarla con el siguiente comando:

```bash
sudo apt-get install logrotate
```

La configuración de Logrotate se realiza principalmente a través de archivos de configuración ubicados en el directorio `/etc/logrotate.d/`. Cada archivo en este directorio define la configuración para un conjunto específico de archivos de registro.

Para crear un archivo de configuración para un registro específico, creamos un nuevo archivo en el directorio `/etc/logrotate.d/`. Por ejemplo, si deseamos configurar la rotación de registros para Apache, creamos un archivo llamado `apache2` en ese directorio:

```bash
sudo nano /etc/logrotate.d/apache2
```

Dentro del archivo de configuración, definimos cómo deseamos que Logrotate maneje los registros específicos. Por ejemplo:

```plaintext
/var/log/apache2/*.log {
    weekly
    missingok
    rotate 4
    compress
    delaycompress
    notifempty
    create 640 root adm
    sharedscripts
    postrotate
        /etc/init.d/apache2 reload > /dev/null
    endscript
}
```

   - `weekly`: Indica que la rotación de registros debe ocurrir semanalmente. Otros valores posibles son `daily`, `monthly`, `yearly` o `size <tamaño>` para rotar basado en el tamaño del archivo.
   - `missingok`: Ignora los archivos de registro que faltan.
   - `rotate 4`: Mantiene hasta 4 versiones anteriores del archivo de registro.
   - `compress` y `delaycompress`: Comprime los archivos de registro antiguos, con `delaycompress` que comprime el archivo anterior solo después de la rotación del próximo archivo.
   - `notifempty`: No rota el archivo si está vacío.
   - `create 640 root adm`: Crea un nuevo archivo de registro con los permisos especificados.
   - `sharedscripts`: Ejecuta el script de post-rotación una vez para todos los archivos de registro definidos.
   - `postrotate` y `endscript`: Ejecuta comandos específicos después de la rotación de registros, como reiniciar el servicio Apache en este caso.

Antes de implementar la configuración, puedes probarla utilizando la opción `-d` para ejecutar Logrotate en modo de depuración:

```bash
sudo logrotate -d /etc/logrotate.conf
```

Logrotate suele ejecutarse automáticamente a través de un cronjob programado. Por defecto, la configuración de cron para Logrotate está en `/etc/cron.daily/logrotate`. Esto garantiza que la rotación de registros se realice de forma regular según la configuración definida.

Con estas configuraciones, Logrotate gestionará automáticamente la rotación y compresión de los archivos de registro de Apache, lo que ayudará a mantener un uso eficiente del espacio en disco y a facilitar la gestión de los registros del servidor. Es importante revisar y ajustar la configuración de Logrotate según sea necesario para adaptarse a las necesidades específicas del servidor y de las aplicaciones que se estén ejecutando.

Volviendo a la diectiva `ErrorLog`, tengamos en cuenta que el archivo de registro de errores puede contener información sensible sobre el servidor y las solicitudes de los clientes, es importante asegurar adecuadamente el acceso al archivo de registro para evitar la filtración de información confidencial.

Otra directiva importante es `ErrorLogFormat`, que se utiliza para personalizar el formato de los mensajes de error que se registran en el archivo de log de errores especificado por la directiva `ErrorLog`. 

La configuración de `ErrorLogFormat` sigue la siguiente sintaxis:

```apache
ErrorLogFormat format_string
```

Donde `format_string` es una cadena de texto que especifica el formato deseado para los mensajes de error registrados. Esta cadena puede contener marcadores de formato que serán reemplazados por valores específicos de cada mensaje de error.

Algunos marcadores de formato comunes que podemos utilizar en `format_string` son:

- `%T`: El tiempo en segundos desde el inicio del servidor.
- `%t`: La fecha y hora del mensaje de error en formato "Common Log Format".
- `%S`: El nombre del servidor.
- `%M`: El nombre del módulo que generó el mensaje de error.
- `%F`: El nombre del archivo donde ocurrió el error.
- `%L`: El número de línea en el archivo donde ocurrió el error.
- `%E`: El nivel de gravedad del mensaje de error (por ejemplo, "error", "warning", "notice").

Por ejemplo, para especificar un formato personalizado que incluya la fecha y hora, el nivel de gravedad y el mensaje de error, utilizamos algo así:

```apache
ErrorLogFormat "[%t] [%l] %M: %E: %F:%L %R"
```

Esto producirá un formato de registro similar a:

```
[Wed Oct 05 14:43:32 2022] [error] mod_ssl: SSL handshake failed: SSL error: Aborted: SSL input filter read failed: No error: /path/to/file:123 GET /example.html HTTP/1.1
```

Es importante tener en cuenta que la personalización del formato de los mensajes de error puede ser útil para adaptarse a las necesidades específicas de monitoreo y diagnóstico del servidor, pero también puede afectar la legibilidad y la compatibilidad con herramientas de análisis de registros existentes. Por lo tanto, es recomendable evaluar cuidadosamente los requisitos y las implicaciones antes de definir un formato personalizado para los registros de errores.

La tercera y última directiva relacionada con los archivos de registro es `LogLevel` que se utiliza para establecer el nivel de detalle de los mensajes de registro que se escriben en los archivos de registro del servidor web. Esta directiva controla qué tipos de mensajes se registrarán en los archivos de registro y es útil para ajustar la cantidad de información registrada.

El nivel de detalle se especifica utilizando uno de los siguientes niveles de registro:

- `emerg`: Se utilizan para situaciones de emergencia que requieren una acción inmediata. Estos mensajes indican que el servidor está experimentando un problema grave y es probable que se requiera una intervención inmediata.

- `alert`: Se utilizan para situaciones de alerta que requieren atención inmediata. Estos mensajes indican que el servidor ha detectado una situación potencialmente peligrosa que debe abordarse de inmediato.
  
- `crit`: Se utilizan para situaciones críticas que requieren atención inmediata. Estos mensajes indican que el servidor ha encontrado un problema crítico que puede afectar gravemente su funcionamiento.
  
- `error:` Se utilizan para informar sobre errores que no son críticos pero que aún requieren atención. Estos mensajes indican que el servidor ha encontrado un problema que necesita ser corregido, pero que no afectará gravemente su funcionamiento.
  
- `warn:` Se utilizan para advertencias que pueden indicar problemas potenciales. Estos mensajes indican que el servidor ha detectado una situación que puede requerir atención, pero que no es necesariamente un error.
  
- `notice:` Se utilizan para mensajes informativos que no son errores. Estos mensajes proporcionan información útil sobre el funcionamiento normal del servidor.
  
- `info:` Se utilizan para mensajes de información general. Estos mensajes proporcionan detalles sobre el funcionamiento normal del servidor y pueden ser útiles para el monitoreo y la depuración.
  
- `debug:` Se utilizan para mensajes de depuración que proporcionan detalles adicionales sobre el funcionamiento interno del servidor. Estos mensajes son útiles para la depuración y el análisis detallado del comportamiento del servidor.

Para configurar `LogLevel`, se debe utilizar la siguiente sintaxis en el archivo de configuración de Apache (por ejemplo, `httpd.conf`):

```apache
LogLevel level
```

Donde `level` es el nivel de detalle deseado de los mensajes de registro. Por ejemplo, para establecer el nivel de registro en `warn`:

```apache
LogLevel warn
```

Esto aseguraría que solo se registren advertencias y mensajes más graves en los archivos de registro de Apache. Dependiendo de las necesidades específicas del servidor y del propósito del registro, puedes ajustar `LogLevel` para aumentar o disminuir la cantidad de información registrada.

## ACTIVIDAD PRÁCTICA.

Configuración de Registro de Errores y Rotación de Registros en Apache

Objetivo: Familiarizarse con la configuración de registro de errores y la rotación de registros en Apache para garantizar un registro eficiente de eventos del servidor y gestionar adecuadamente el tamaño de los archivos de registro.

Instrucciones:

1. Investiga y comprende el propósito y la importancia de la configuración de registro de errores en Apache, así como el proceso de rotación de registros que se ha explicado en el texto.

2. Crea un directorio de práctica en tu servidor Apache donde realizarás la configuración de registro de errores y rotación de registros.

3. Edita el archivo de configuración principal de Apache para especificar la ubicación del archivo de registro de errores utilizando la directiva `ErrorLog`. Asegúrate de asignar permisos adecuados al archivo de registro para que el usuario del servidor web tenga permisos de escritura.

4. Utiliza la herramienta de rotación de registros `logrotate` para configurar la rotación de los archivos de registro de Apache. Crea un archivo de configuración para Apache en el directorio `/etc/logrotate.d/` con las opciones de rotación deseadas, como la frecuencia de rotación (que debe ser alta), el número de archivos a mantener y la compresión de archivos antiguos.

5. Verifica la configuración de logrotate utilizando la opción `-d` para ejecutarlo en modo de depuración y asegúrate de que no haya errores en la configuración.

6. Reinicia el servidor Apache para aplicar los cambios en la configuración de registro de errores.

7. Realiza pruebas en tu servidor web, generando solicitudes y eventos que se registren en el archivo de registro de errores. Verifica que los mensajes de error se estén registrando correctamente en el archivo especificado.

8. Observa el comportamiento de la rotación de registros, verificando que los archivos de registro se estén rotando según la configuración definida en logrotate y que no se exceda el número máximo de archivos especificado.


## DocumentRoot

`DocumentRoot` es una directiva de configuración en Apache que especifica el directorio base en el sistema de archivos del servidor desde el cual se sirven los archivos del sitio web. Es decir, `DocumentRoot` define la ubicación en el servidor donde Apache buscará los archivos que deben ser accesibles a través del protocolo HTTP.

Cuando un cliente realiza una solicitud HTTP (request) a un servidor Apache, el servidor buscará los archivos correspondientes dentro del directorio especificado por `DocumentRoot` y enviará esos archivos como respuesta (response) a la solicitud del cliente.

La ruta especificada en `DocumentRoot` debe ser una ruta absoluta en el sistema de archivos del servidor. Por ejemplo, `/var/www/html` o `/usr/local/apache2/htdocs`. Esta ruta puede variar dependiendo de la distribución del sistema operativo y la configuración específica de Apache.

Es importante asegurarse de que los archivos y directorios dentro de `DocumentRoot` tengan los permisos adecuados para que Apache pueda acceder a ellos y servirlos a los clientes. Esto incluye configurar permisos de lectura y ejecución adecuados para el usuario bajo el cual se ejecuta Apache (generalmente `www-data`) y asegurarse de que los archivos confidenciales estén protegidos contra accesos no autorizados.

`DocumentRoot` se puede configurar globalmente en el archivo de configuración principal de Apache (como `httpd.conf` o `apache2.conf`) o en la configuración de hosts virtuales (virtual hosts), que aún tenemos pendiente de explicar. En el caso de los hosts virtuales, cada host virtual puede tener su propio `DocumentRoot`, lo que permite alojar múltiples sitios web en un solo servidor.


## Redirección.

La directiva `Redirect` en Apache se utiliza para redireccionar solicitudes de una URL a otra. Esto es útil cuando deseamoss que los usuarios sean redirigidos automáticamente desde una ubicación a otra, ya sea dentro del mismo sitio web o a un sitio web diferente.

La sintaxis básica de la directiva `Redirect` es la siguiente:

```apache
Redirect [status] URL-path URL
```

Donde:
- `status` es un código de estado HTTP opcional, como 301 (Redirección permanente) o 302 (Redirección temporal). Si no se proporciona un código de estado, se utiliza el valor predeterminado 302.
- `URL-path` es el fragmento de la URL a la que desemos redirigir.
- `URL` es la dirección URL a la que deseas redirigir la solicitud.

Por ejemplo, para redirigir todas las solicitudes desde `/old-page` a `/new-page`, podemos usar la siguiente directiva:

```apache
Redirect /old-page /new-page
```

Esto redirigirá todas las solicitudes que coincidan con `/old-page` a `/new-page` en el mismo dominio.

También podemos especificar el código de estado en la directiva. Por ejemplo, para realizar una redirección permanente (código de estado 301), puedes hacer lo siguiente:

```apache
Redirect 301 /old-page http://example.com/new-page
```

Esto redirigirá todas las solicitudes desde `/old-page` a `http://example.com/new-page` con un código de estado 301.

Es importante tener en cuenta que la directiva `Redirect` solo redirige la solicitud actualmente procesada por Apache. Si desea,oss redirigir todas las solicitudes a un sitio web diferente, es posible que necesitemos considerar el uso de la directiva `RedirectMatch` o reglas de redirección basadas en expresiones regulares en conjunto con módulos de reescritura como `mod_rewrite` (explicado más adelante). 

La directiva `RedirectMatch` en Apache se utiliza para redirigir solicitudes de URL que coinciden con un patrón específico a una nueva URL. A diferencia de la directiva `Redirect`, que solo coincide con una URL exacta, `RedirectMatch` permite utilizar expresiones regulares para hacer coincidir múltiples URLs y realizar redirecciones más flexibles y complejas.

La sintaxis básica de `RedirectMatch` es la siguiente:

```apache
RedirectMatch [status] regex URL
```

- `status` (opcional): El código de estado HTTP que se enviará al cliente como parte de la respuesta de redireccionamiento. Por ejemplo, 301 para redirecciones permanentes o 302 para redirecciones temporales. Si no se especifica, se utiliza el código de estado 302 de forma predeterminada.
   
- `regex`: La expresión regular que se utilizará para hacer coincidir la parte de la URL que se va a redirigir.
   
- `URL`: La URL de destino a la que se redirigirá la solicitud.

Ejemplos de uso:
   
Redirigir una URL específica a una nueva ubicación:

```apache
RedirectMatch 301 /oldpage.html /newpage.html
```


Redirigir todas las solicitudes de un directorio a una nueva ubicación:
     
```apache
RedirectMatch 301 /blog/(.*) /newblog/$1
```
En el contexto de las expresiones regulares y las redirecciones de Apache, `(.*)` y `$1` son elementos importantes que se utilizan para capturar y referirse a partes específicas de una URL.

En una expresión regular, `(.*)` es un patrón que se utiliza para capturar cualquier secuencia de caracteres de longitud variable. El `.` coincide con cualquier carácter (excepto saltos de línea) y `*` indica que el carácter anterior puede aparecer cero o más veces.

Por ejemplo, si tenemos la expresión regular `RedirectMatch ^/blog/(.*) /newblog/$1`, el `(.*)` capturará cualquier secuencia de caracteres después de "/blog/" en la URL original y lo almacenará para su uso posterior.

`$1` se utiliza para hacer referencia al primer grupo de captura definido en la expresión regular. Cada conjunto de paréntesis `()` en la expresión regular crea un grupo de captura, y `$1` se refiere al contenido capturado por el primer grupo de captura, `$2` al segundo grupo, y así sucesivamente.

Por ejemplo, en la expresión regular anterior `RedirectMatch ^/blog/(.*) /newblog/$1`, `$1` se sustituirá por la parte de la URL capturada por `(.*)` en la URL de destino de la redirección. Esto significa que cualquier texto capturado después de ***/blog/*** en la URL original se incluirá en la URL de destino después de ***/newblog/*** en la redirección.

Debemos sacar en claro que, `(.*)` se utiliza para capturar partes de una URL, mientras que `$1` se utiliza para referirse al contenido capturado por `(.*)` y se inserta en la URL de destino de una redirección en Apache. Juntos, permiten redirigir dinámicamente diferentes partes de una URL a ubicaciones específicas.

Otro ejemplo más. Redirigir todas las solicitudes HTTP a HTTPS:

```apache
RedirectMatch 301 ^/(.*)$ https://example.com/$1
```

## ACTIVIDAD PRÁCTICA.

Redirección de URLs en Apache utilizando `Redirect` y `RedirectMatch`

Objetivo: Practicar el uso de las directivas Redirect y RedirectMatch en Apache para redireccionar solicitudes de URLs a nuevas ubicaciones, tanto dentro del mismo sitio web como a sitios web diferentes, utilizando la resolución de DNS local mediante el archivo `/etc/hosts`.

Instrucciones:

1. Investiga y comprende el propósito y la sintaxis de las directivas Redirect y RedirectMatch en Apache, así como su diferencia y cuándo es apropiado utilizar cada una, tal y como se ha explicado en el texto.

2. Configura el archivo `/etc/hosts` en tu servidor para que el nombre de dominio `example.com` se resuelva a la dirección IP de `localhost` (127.0.0.1). 

3. Crea un directorio de práctica en tu servidor Apache donde realizarás las pruebas de redirección de URLs.

4. Crea páginas web simples en HTML para representar las URLs de origen y destino de las redirecciones. Por ejemplo, puedes crear una página llamada `old-page.html` en la que incluyas un mensaje que indique que es la página antigua, y otra página llamada `new-page.html` que contenga un mensaje indicando que es la nueva página.

5. Edita el archivo de configuración de Apache correspondiente (por ejemplo, `apache.conf` o un archivo `.htaccess` en el directorio de práctica) para agregar las directivas `Redirect` y `RedirectMatch` según sea necesario para las siguientes redirecciones:

   a. Redirige la URL `/old-page.html` a `/new-page.html` en el mismo dominio utilizando la directiva `Redirect`.

   b. Redirige la URL `/blog/old-post.html` a `/new-blog/new-post.html` en el mismo dominio utilizando la directiva `RedirectMatch`.

   c. Realiza una redirección permanente (código de estado 301) desde `http://example.com/old-site.html` a `http://new-example.com/new-site.html` utilizando la directiva `RedirectMatch`.

6. Reinicia el servidor Apache para aplicar los cambios en la configuración.

7. Verifica las redirecciones accediendo a las URLs originales y observa si son redirigidas automáticamente a las nuevas ubicaciones especificadas.

8. Verifica los códigos de estado HTTP devueltos por las redirecciones utilizando las herramientas de desarrollo del navegador.


[Vamos al siguiente contenido](./20-C.md)
