
# Conexión Apache2 <> Apache Tomcat

Conectar **Apache HTTP Server** (httpd) con **Apache Tomcat** permite usar Apache como servidor frontal que maneja las peticiones HTTP estáticas (como imágenes, CSS, JS) y redirige las dinámicas (como servlets y JSPs) a Tomcat. Esto se hace principalmente por eficiencia y flexibilidad.

### Formas comunes de conectar Apache con Tomcat:

#### 1. **Usar el módulo `mod_proxy` (recomendado, es el método moderno de conexión)**

Es el método más actual y mantenido. Utiliza `mod_proxy` y `mod_proxy_ajp` o `mod_proxy_http`.

##### a) **Habilita los módulos necesarios**:

En Debian/Ubuntu:

```bash
sudo a2enmod proxy
sudo a2enmod proxy_ajp   # o proxy_http
sudo systemctl restart apache2
```

##### b) **Configura el VirtualHost en Apache**:

```apache
<VirtualHost *:80>
    ServerName midominio.com

    ProxyPass /app ajp://localhost:8009/app
    ProxyPassReverse /app ajp://localhost:8009/app
</VirtualHost>
```

O con HTTP en lugar de AJP (si AJP está deshabilitado):

```apache
<VirtualHost *:80>
    ServerName midominio.com

    ProxyPass /app http://localhost:8080/app
    ProxyPassReverse /app http://localhost:8080/app
</VirtualHost>
```

Suponiendo que haya una app instalada en `http://localhost:8080/app` en Apache Tomcat

##### Apache Tomcat y el protocolo AJP (Apache JServ Protocol)

En el puerto **8009**, por defecto, **Apache Tomcat escucha el protocolo AJP (Apache JServ Protocol)**. Este protocolo se usa para conectar servidores web como **Apache HTTP Server o Nginx** con Tomcat, generalmente en una arquitectura donde:

* **Apache HTTP Server** sirve contenido estático (HTML, imágenes, CSS).
* **Tomcat** sirve contenido dinámico (JSPs, servlets, etc.).
* El tráfico entre Apache y Tomcat viaja por **AJP** en el puerto 8009.

---

### ¿Cómo sé si está activado?

Puedes mirar en el archivo:

```bash
/opt/tomcat/conf/server.xml
```

Busca esta sección:

```xml
<Connector port="8009" protocol="AJP/1.3" redirectPort="8443" />
```

Si esa línea **está comentada**, entonces Tomcat no tiene activo el Conector AJP y por tanto no está escuchando en el puerto 8009.

---

### Verificar si Tomcat escucha en el puerto 8009

Usa este comando:

```bash
sudo ss -tuln | grep 8009
```

Deberías ver una línea como:

```
LISTEN  0  100  *:8009  *:*
```

Si no ves nada, Tomcat no está escuchando ahí. Puede estar desactivado o comentado en `server.xml`.

---

### ¿Debo dejarlo activado?

No necesariamente. **AJP ha tenido vulnerabilidades importantes** (como Ghostcat en 2020), y si **no estás usando Apache o Nginx con AJP**, es más seguro deshabilitarlo.

Para desactivarlo, simplemente comenta o elimina esta línea en `server.xml`:

```xml
<!--
<Connector port="8009" protocol="AJP/1.3" redirectPort="8443" />
-->
```

Luego reinicia Tomcat:

```bash
sudo systemctl restart tomcat
```

##### RECORDATORIO: Comprobar configuración activa en Apache2

Para ver los sitios habilitados en Apache2 en sistemas como Ubuntu/Debian puedes usar:

```bash
ls /etc/apache2/sites-enabled/
```

Este directorio contiene enlaces simbólicos a los archivos reales de configuración que están en:

```bash
/etc/apache2/sites-available/
```

---

### **Ver qué sitios están habilitados y su contenido**

1. **Listar los sitios habilitados:**

```bash
ls -l /etc/apache2/sites-enabled/
```

2. **Ver el contenido de un sitio habilitado:**

```bash
cat /etc/apache2/sites-enabled/000-default.conf
```

o abre el archivo con un editor:

```bash
sudo nano /etc/apache2/sites-enabled/000-default.conf
```

---

### **Comando extra: comprobar configuración activa**

Para ver un resumen de la configuración actual y sitios cargados:

```bash
apache2ctl -S
```

Este comando muestra:

* Qué archivos de configuración están cargados
* Qué VirtualHosts están definidos
* Qué puertos están escuchando
* Y si hay errores de configuración



##### Acceder Apache Tomcat Home y con el protocolo http

Antes habíamos habilitado una serie de módulos de proxy con

```bash
sudo a2enmod proxy
sudo a2enmod proxy_ajp   # o proxy_http
sudo systemctl restart apache2
```

Pero con estos módulos solo, esta configuración que redirige a la Home de Tomcat dará error:


*Archivo apachetomcat.conf en `sites-available` y `sites-enabled` *  
```apache
<VirtualHost *:80>
    ServerName midominio.com

    ProxyPreserveHost On
    ProxyPass / http://localhost:8080/
    ProxyPassReverse / http://localhost:8080/

    ErrorLog ${APACHE_LOG_DIR}/midominio_error.log
    CustomLog ${APACHE_LOG_DIR}/midominio_access.log combined
</VirtualHost>
```

Esta configuracion no tirará Apache, pero dará un error, porque proxy por si solo, no es suficiente, hay que habilitar sub modulos que aportan mas funcionalidades, como proxy_http (que estaba comentado en los dos ejemplos).

Generará un error y la home de apache no cargará. En el log archivado en: `/var/log/apache2/midominio_error.log` veremos una mención de error del tipo *`...If you are using a dso of mod_proxy make sure proxy submodules are included in the configuration load module...`*.

Ese mensaje significa que **si estás cargando `mod_proxy` como módulo dinámico (DSO = Dynamic Shared Object)**, necesitas asegurarte de que también cargas los **submódulos necesarios** de proxy en tu configuración de Apache.

---

## ¿Qué quiere decir esto exactamente?

`mod_proxy` es el módulo base, pero **no hace nada por sí solo**. Necesitas habilitar también los submódulos según el tipo de proxy que vayas a usar:

| Submódulo                 | ¿Para qué sirve?                              |
| ------------------------- | --------------------------------------------- |
| `mod_proxy_http`          | Para proxys hacia servidores HTTP/HTTPS       |
| `mod_proxy_ajp`           | Para proxys hacia Tomcat por AJP              |
| `mod_proxy_balancer`      | Para balanceo de carga                        |
| `mod_lbmethod_byrequests` | Método de balanceo "por número de peticiones" |

---

## ¿Cómo habilitar los submódulos necesarios?

En sistemas basados en Debian/Ubuntu:

```bash
sudo a2enmod proxy
sudo a2enmod proxy_http
sudo a2enmod proxy_balancer
sudo a2enmod lbmethod_byrequests
```

Y luego reinicia Apache:

```bash
sudo systemctl restart apache2
```

---

## Por tanto:

Ese mensaje es solo un recordatorio técnico: **habilita los submódulos correctos según el tipo de proxy que usas**, o Apache no sabrá cómo manejar las instrucciones `ProxyPass`, `BalancerMember`, etc.  
  
Por tanto, tendremos que hacer
```bash
# sudo a2enmod proxy # ya hecho
sudo a2enmod proxy_http
# sudo a2enmod proxy_balancer # no necesario aun
# sudo a2enmod lbmethod_byrequests # no necesario aun
```

Y después

```bash
sudo systemctl restart apache2
```

Y al cargar en el navegador: `http://midominio.com`, veremos la home de Apache Tomcat


#### 2. **Usar `mod_jk` (antiguo y menos recomendable ahora)**

Este módulo conecta Apache y Tomcat usando el protocolo AJP, pero está en desuso frente a `mod_proxy`.

##### a) Instalar `mod_jk`:

En Debian/Ubuntu:

```bash
sudo apt-get install libapache2-mod-jk
```

##### b) Configurar `workers.properties`:

Archivo típico en `/etc/libapache2-mod-jk/workers.properties`:

```properties
worker.list=tomcat
worker.tomcat.type=ajp13
worker.tomcat.host=localhost
worker.tomcat.port=8009
```

##### c) Configurar el VirtualHost:

```apache
<VirtualHost *:80>
    ServerName midominio.com
    JkMount /app/* tomcat
</VirtualHost>
```

Sí, esa configuración Apache con `mod_jk`:

```apache
<VirtualHost *:80>
    ServerName midominio.com
    JkMount /app/* tomcat
</VirtualHost>
```

**redirige cualquier petición a `/app/*` en Apache hacia una app montada en `/app` en Tomcat** — siempre y cuando:

---

### 1. **Tengas `mod_jk` instalado y configurado**

Debes tener estas piezas funcionando:

* `mod_jk` cargado:

  ```bash
  sudo a2enmod jk
  ```

* Archivo `workers.properties` (por ejemplo en `/etc/libapache2-mod-jk/workers.properties`):

  ```properties
  worker.list=tomcat
  worker.tomcat.type=ajp13
  worker.tomcat.host=localhost
  worker.tomcat.port=8009
  ```

* Línea en tu `apache2.conf` o similar para vincular `mod_jk` con ese archivo:

  ```apache
  JkWorkersFile /etc/libapache2-mod-jk/workers.properties
  ```

---

### 2. **Tu app esté desplegada en Tomcat bajo el contexto `/app`**

Esto significa que en Tomcat deberías tener algo como:

* `webapps/app/` (directorio desplegado)
* o `webapps/app.war` (que se autoexpande)

Y la aplicación debe responder correctamente a rutas tipo `/app/index.jsp`, `/app/login`, etc.

---

### 3. **Tomcat tenga habilitado el conector AJP**

En `conf/server.xml` debe haber un bloque como este (y sin estar comentado):

```xml
<Connector port="8009" protocol="AJP/1.3" redirectPort="8443" />
```

Desde Tomcat 9.0.31 y 10 en adelante, el conector AJP está **deshabilitado por defecto** por seguridad. Para activarlo:

```xml
<Connector port="8009" protocol="AJP/1.3" address="127.0.0.1" secretRequired="false" />
```

---

### Si ves un 503 o error 500 en Apache:

Significa que Apache no puede comunicarse con Tomcat por AJP — probablemente por uno de estos motivos:

* El conector AJP está desactivado.
* El puerto está mal.
* Apache no puede alcanzar a Tomcat (firewall, IP incorrecta, etc.).
* La app no existe en `/app`.

---

### Recomendaciones:

* **mod\_proxy** es más simple, moderno y mantenido.
* Asegúrate de que Tomcat esté escuchando en el puerto adecuado (por defecto 8080 para HTTP, 8009 para AJP).
* Puedes añadir reglas adicionales para redirigir solo ciertas rutas a Tomcat.

### Acerca de AJP:

**AJP (Apache JServ Protocol)** es un protocolo binario optimizado para conectar un servidor web (como **Apache HTTP Server**) con un contenedor de aplicaciones Java (como **Apache Tomcat**).

### ¿Qué hace AJP?

Permite que Apache pase solicitudes a Tomcat eficientemente, especialmente útil para contenido dinámico (servlets, JSP). Apache maneja las peticiones HTTP y transfiere solo lo necesario a Tomcat.

---

### Ventajas del AJP:

* Es más rápido que usar HTTP normal entre Apache y Tomcat (por ser binario).
* Permite mantener la configuración de seguridad y rendimiento en Apache y dejar Tomcat dedicado solo a servir aplicaciones Java.

---

### Cómo funciona (flujo básico):

1. Usuario accede a `http://midominio.com/app`
2. Apache recibe la solicitud.
3. Apache usa AJP para reenviar la petición a Tomcat en el puerto **8009**.
4. Tomcat responde a Apache.
5. Apache entrega la respuesta al cliente.

---

### ¿Por qué se está usando menos?

* En 2020, el **conector AJP de Tomcat fue deshabilitado por defecto** debido a vulnerabilidades (como Ghostcat - CVE-2020-1938).
* Requiere más configuración de seguridad (restringir IPs, etc.).
* Muchos entornos modernos prefieren usar `mod_proxy_http` por simplicidad y menor riesgo.

---

### ¿Cuándo usar AJP hoy?

* Si necesitas máximo rendimiento en una red privada y puedes controlar bien la seguridad.
* Si estás manteniendo una infraestructura existente que ya lo usa.

---
---

Tener múltiples instancias de **Apache Tomcat** en una misma máquina es perfectamente posible y útil para entornos de desarrollo, pruebas de balanceo de carga o aislamiento de aplicaciones. A continuación te explico cómo hacerlo paso a paso.

---

## Multiples Instancias de Apache Tomcat en la misma maquina (para el Balanceo de Carga)

### 1. ¿Qué necesitas cambiar para que funcionen varias instancias?

Cada instancia de Tomcat necesita:

* Un **directorio de instalación separado**
* Un conjunto distinto de **puertos** (HTTP, AJP, shutdown)
* Scripts de inicio y configuración separados
* Opcionalmente, variables de entorno distintas

---

### 2. Supuestos iniciales

* Vamos a instalar dos instancias: `tomcat1` y `tomcat2`
* Los directorios base estarán en `/opt/tomcat1/` y `/opt/tomcat2/`
* Los puertos serán:

  * `tomcat1`: HTTP 8080, Shutdown 8005
  * `tomcat2`: HTTP 8081, Shutdown 8006

---

### 3. Tener instalado Tomcat (base común)

Esto ya lo teniamos con el primer tomcat

```bash
cp -r /opt/tomcat /opt/tomcat2
```
Ahora tienes dos carpetas: `/opt/tomcat1` y `/opt/tomcat2`

---

### 4. Modificar puertos en `server.xml`

#### Instancia 1 (`tomcat`)

Archivo: `/opt/tomcat1/conf/server.xml`

```xml
<Server port="8005" shutdown="SHUTDOWN">
  <Service name="Catalina">
    <Connector port="8080" protocol="HTTP/1.1" />
    <!-- AJP opcional -->
  </Service>
</Server>
```

#### Instancia 2 (`tomcat2`)

Archivo: `/opt/tomcat2/conf/server.xml`

```xml
<Server port="8006" shutdown="SHUTDOWN2">
  <Service name="Catalina">
    <Connector port="8081" protocol="HTTP/1.1" />
    <!-- AJP opcional -->
  </Service>
</Server>
```

En caso de AJP o SSL también, nos tendremos que asegurarnos el cambiar esos puertos para evitar conflictos.

---

### 5. Arrancar cada instancia

Desde sus respectivos directorios:

```bash
/opt/tomcat/bin/startup.sh
/opt/tomcat2/bin/startup.sh
```

Para detenerlas:

```bash
/opt/tomcat/bin/shutdown.sh
/opt/tomcat2/bin/shutdown.sh
```

Puedes probarlas con curl o navegador:

```bash
curl http://localhost:8080
curl http://localhost:8081
```

Deberías ver la página de bienvenida de Tomcat en ambas.

---

### 6. Opcional: configurar variables de entorno

Puedes usar variables como `CATALINA_HOME` y `CATALINA_BASE` para separar aún más las configuraciones si lo deseas, sobre todo si quieres compartir binarios pero cambiar `conf`, `logs`, `webapps`, etc.

---

### 7. Consideraciones

* Asegúrate de que el firewall no bloquee los puertos.
* No pongas las dos instancias en el mismo puerto o causará conflicto al iniciar.
* Puedes configurar el acceso con Apache (proxy inverso y balanceador) para unificar el acceso externo.

---
---

## NOSOTROS YA TENIAMOS UNA INSTANCIA DE TOMCAT ACTIVA

Entonces lo que tenemos que hacer es:

---

## 1. Copia la instancia existente

Como la instancia actual está en `/opt/tomcat`, la copiamos (ya lo habiamos indicado antes):

```bash
cp -r /opt/tomcat /opt/tomcat2
```

Esto crea una nueva instancia en `/opt/tomcat2` con los mismos archivos.

---

## 2. Cambiamos los puertos en `tomcat2`

Edita el archivo `/opt/tomcat2/conf/server.xml` y cambia los puertos para evitar conflictos.

### Cambios recomendados:

* `Shutdown` de 8005 → 8006
* `HTTP` de 8080 → 8081
* Si usas `AJP`, cámbialo también (por ejemplo, de 8009 → 8010)

Ejemplo:

```xml
<Server port="8006" shutdown="SHUTDOWN2">
  <Service name="Catalina">
    <Connector port="8081" protocol="HTTP/1.1" connectionTimeout="20000" />
    <!-- AJP opcional -->
  </Service>
</Server>
```

---

## 3. Asignamos permisos de archivos al usuario tomcat2

## Creamos el usuario para `tomcat2`

```bash
sudo useradd -r -m -U -d /opt/tomcat2 -s /bin/false tomcat2
```

Esto crea:

* Usuario: `tomcat2`
* Grupo: `tomcat2`
* Directorio home (no necesario, pero útil): `/opt/tomcat2`

---

## Dar permisos al usuario sobre Tomcat 2

Nos aseguraamos de que el directorio de instalación pertenece a `tomcat2`:

```bash
sudo chown -R tomcat2:tomcat2 /opt/tomcat2
```

Y opcionalmente podemos aseguramos de que todos los archivos sean legibles:

```bash
sudo chmod -R 755 /opt/tomcat2
```

---

## Actualizar el archivo del servicio systemd

Editamos el archivo `/etc/systemd/system/tomcat2.service` para que use el nuevo usuario:

```ini
[Unit]
Description=Apache Tomcat 2
After=network.target

[Service]
Type=forking

User=tomcat2
Group=tomcat2

Environment="JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64"
Environment="CATALINA_BASE=/opt/tomcat2"
Environment="CATALINA_HOME=/opt/tomcat2"
Environment="CATALINA_PID=/opt/tomcat2/temp/tomcat.pid"
Environment="JAVA_OPTS=-Djava.security.egd=file:/dev/./urandom"

ExecStart=/opt/tomcat2/bin/startup.sh
ExecStop=/opt/tomcat2/bin/shutdown.sh

Restart=on-failure

[Install]
WantedBy=multi-user.target
```

---

## Recargamos systemd y reiniciamos el servicio

```bash
sudo systemctl daemon-reload
sudo systemctl restart tomcat2
```

Verificamos que el proceso corre bajo `tomcat2`:

```bash
ps aux | grep tomcat2
```

---

## Probamos el acceso

En navegador o con `curl`:

```bash
curl http://localhost:8081
```

Deberia haber respuesta.

---

## 4. Arranca la nueva instancia

```bash
/opt/tomcat2/bin/startup.sh
```

Verifica que está funcionando:

```bash
curl http://localhost:8081
```

Si todo está bien, deberías ver la página de bienvenida de Tomcat o un mensaje HTML desde el puerto 8081.

---

## 5. Verifica que ambas instancias funcionan a la vez

* `http://localhost:8080` → instancia original
* `http://localhost:8081` → instancia nueva


## PROBABLMENTE TENGAMOS PROBLEMAS Y LAS DOS INSTANCIAS SE QUEDEN PILLADAS

Hemos arrancado la segunda instancia de Tomcat y no la podemos parar a no se que matemos el proceso. Al haber clonado la carpeta del primer tomcat, probablemente los archivos temporales estén dando problemas.  

Además, no es cómo gestionar el segundo Tomcat, con lo cual, lo mejor que podemos hacer es definir un segundo servicio.

### Pasos que vamos a realizar

1. **Limpiar la segunda instancia de Tomcat** (borrar archivos temporales y dejarla lista).
2. **Crear un servicio systemd** para que puedas arrancar, detener o habilitar Tomcat 2 como un servicio del sistema, igual que el primero.

---

## 1. Limpieza de Tomcat 2

Elimina archivos temporales, logs y trabajos compilados:

```bash
rm -rf /opt/tomcat2/logs/*
rm -rf /opt/tomcat2/temp/*
rm -rf /opt/tomcat2/work/*
```

Con eso, tu instancia está limpia y lista para reiniciar sin basura acumulada.

---

## 2. Crear un servicio systemd para Tomcat 2

### Paso 1: Crear el archivo de servicio

Archivo: `/etc/systemd/system/tomcat2.service`

```ini
[Unit]
Description=Apache Tomcat 2
After=network.target

[Service]
Type=forking

User=root
Group=root

Environment="JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64"
Environment="CATALINA_BASE=/opt/tomcat2"
Environment="CATALINA_HOME=/opt/tomcat2"
Environment="CATALINA_PID=/opt/tomcat2/temp/tomcat.pid"
Environment="JAVA_OPTS=-Djava.security.egd=file:/dev/./urandom"

ExecStart=/opt/tomcat2/bin/startup.sh
ExecStop=/opt/tomcat2/bin/shutdown.sh

Restart=on-failure

[Install]
WantedBy=multi-user.target
```

Ajusta `JAVA_HOME` según tu instalación (cogelo del JAVA_HOME del archivo: `/etc/systemd/system/tomcat.service`

---

### Paso 2: Recargar systemd y habilitar el servicio

```bash
sudo systemctl daemon-reexec
sudo systemctl daemon-reload
sudo systemctl enable tomcat2
sudo systemctl start tomcat2
```

Comprueba que funciona:

```bash
sudo systemctl status tomcat2
```

---

### Paso 3: Verificar acceso

Abre en navegador o curl:

```bash
http://localhost:8081
```

Si ves la página de bienvenida de Tomcat, todo está correcto.




